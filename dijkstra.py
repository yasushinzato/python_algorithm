# -*- coding: utf-8 -*-
"""
Created on Wed Mar  4 16:30:07 2020

ダイクストラ法
ある頂点に接続している頂点を候補とし、その中からコストが最も小さくなる頂点を選択することを繰り返して探索する方法

ベルマン・フォード法　はすべての辺に対して処理を繰り返すが、ダイクストラ法は選択する頂点を工夫して効率よく最短経路を探す。
       5
   ∞ ――――→ ∞
　4/|\ 　　 / ↑ \2 
 /1| \1 /3 |   \
0  |   ∞ 　1|　  ∞
3\ ↓       |  /4
   ∞ ――――→ ∞
       2
       
拡張点から調べるのは1回だけ。辺の数をmとすると O(m)。
アルゴリズム全体では O(m+n^2)

　　　　　　　　　　  n(n-1)
しかし、mは最大で ――――――　なので、O(n^2)となる。
        　　　　　　2
@author: 81909
"""

def dijkstra(edges, num_v):
    dist = [float('inf')] * num_v
    dist[0] = 0
    q = [i for i in range(num_v)]
    
    while len(q) > 0:
        # 最もコストが小さい頂点を探す
        r = q[0]
        for i in q:
            if dist[i] < dist[r]:
                r = i # コストが小さい頂点が見つかれば更新
                
        # 最もコストが小さい頂点を取り出す
        u = q.pop(q.index(r))
        for i in edges[u]:  # 取り出した頂点からの辺を繰り返し
            if dist[i[0]] > dist[u] + i[1]:
                # 頂点までのコストが更新できれば更新
                dist[i[0]] = dist[u] + i[1]
                
    return dist

# 辺のリスト（終点とコストのリスト）
edges = [
    [[1, 4], [2, 3]],  # 頂点Aからの辺のリスト
    [[2, 1], [3, 1], [4, 5]],  # 頂点Bからの辺のリスト
    [[5, 2]],  # 頂点Cからの辺のリスト
    [[4, 3]],  # 頂点Dからの辺のリスト
    [[6, 2]],  # 頂点Eからの辺のリスト
    [[4, 1], [6, 4]],  # 頂点Fからの辺のリスト
    [] # 頂点Gからの辺のリスト
]

print(dijkstra(edges, 7))